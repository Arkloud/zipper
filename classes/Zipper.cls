public class Zipper 
{
    public static String bigZip = '504B030414000808080002266D4700000000000000000000000032000000756E7061636B616765642F74726967676572732F4D65726368616E7441646472657373547269676765722E74726967676572E5545D4BC330147DDFAFC8630BA57F407CE836101FA6D22A822F254B6EEB65310949BA29B2FF6EDAA5C5C21EEC6053304FBD5FE7F4DC1CE20CD63518B202C35EA97419E706AC7D0C6925874A194A60CB9291680D953240505A302E21216C34A70E12422BE7A7FBE2211AD73808701093CF19F1E7A627644A3A7877E49A48D80DE928BE9A757D589128B4A468E71DE96DC7D223B5274C1560B6C8C0A6A69121F5ACCCA6126A17B5E80B2A29472A5F502F140F3885A60C86B63096FAF6A4874D95E0B1FFA1896C9E2593BC68D64BDCA245251F946E0475FE6BE80BD27AF4FD31D159BBBED3351BE0E872B49B82F9DDE54A88461F93BBA27AA4D8C797113D017DE5ED486B983776D2060FB679EAEC785EDBDC7DB7CDFDEFDBE674CD97B54DF121590E1CDE74AB737878FE994FBB2B5B8EDEC9BF7B653FD1B8FF02504B070882804235390100006E060000504B030414000808080002266D470000000000000000000000003B000000756E7061636B616765642F74726967676572732F4D65726368616E7441646472657373547269676765722E747269676765722D6D6574612E786D6C4D8DCB0AC2301444F7F98A90BDB9B148114953BAF10BAAFB905E6BC03C48AEA59F6FA12E3ABB19CE7074BF860F5FB0549F6227CE52098ED1A5C9C7B9138FF17EBA8ADE303D645CC7E2E7190BDF1EB176E24D946F0035D92CEB2B1587D2A5008D522DA80B04243B59B2C230BE45DBEC9FBBC634AD541A0EC34E54B2F4AD6670E417D4F0AF4CC3416ED80F504B070812A482A28A000000B2000000504B030414000808080002266D4700000000000000000000000016000000756E7061636B616765642F7061636B6167652E786D6C4D4FCB0E823010BCF3154DEF76AB12634C29E1E2CDC4037E402D2B10ED236D63F0EF25808F3DCDECCECE6444399807796288BDB3055D334E095AED9ADEB605BDD4C7D59E96321367A5EFAA4532AA6D2C6897923F0044A73C8B37173432ED0C6C38DF01CFC160528D4A8ACA8C8C23D2CB639CF1C40D9AEB18294F1874A76CAA9A26608C75E8DB168380CFFDF761954159791CBE9A6933DBC39FBF58BAC86DCEB8800FCB042C1564F606504B07084E999336A9000000F4000000504B0102140014000808080002266D4782804235390100006E060000320000000000000000000000000000000000756E7061636B616765642F74726967676572732F4D65726368616E7441646472657373547269676765722E74726967676572504B0102140014000808080002266D4712A482A28A000000B20000003B0000000000000000000000000099010000756E7061636B616765642F74726967676572732F4D65726368616E7441646472657373547269676765722E747269676765722D6D6574612E786D6C504B0102140014000808080002266D474E999336A9000000F400000016000000000000000000000000008C020000756E7061636B616765642F7061636B6167652E786D6C504B050600000000030003000D010000790300000000'; 
    
    private Map<String, FileObject> zipFileMap = new Map<String, FileObject>{};
    private Boolean unZipping = false;  //if zipping a file, false.  If UnZipping a file, true
    protected String zipFileString;  // stores the Hex version of the file blob
    
    // Zipper Zip  Contructor
    public Zipper(){}
   
    //  Zipper UnZipping Constructor
    public Zipper(Blob fileData)
    {
        unZipping = true;
        zipFileString = EncodingUtil.convertToHex(fileData);
        Integer offsetOfEndCentralDirSignature = zipFileString.lastIndexOf(endCentralDirSignature);
        
        Long numberOfFiles = HexUtil.hexToIntLittleEndian(zipFileString.substring(offsetOfEndCentralDirSignature+10*2,offsetOfEndCentralDirSignature+10*2+2*2));    //offset 10, 2 bytes
        
        offsetOfStartOfCentralDir = zipFileString.substring(offsetOfEndCentralDirSignature+16*2,offsetOfEndCentralDirSignature+16*2+4*2);
        
        Long startOfCentralDir = HexUtil.hexToIntLittleEndian(offsetOfStartOfCentralDir);  //offset 16, 4 bytes
    
        //System.debug (numberOfFiles + ',  ' + startOfCentralDir);
        Integer offset = (Integer)startOfCentralDir;
        
        for (Integer fileLoop = 0; fileLoop < numberOfFiles; fileLoop++)
        {
            FileObject tempFile = new FileObject(zipfileString, offset);
            zipFileMap.put(EncodingUtil.convertFromHex(tempFile.fileName).toString(), tempFile);
            offset = tempFile.c_offsetToNextRecord;
    
        }
        //System.debug(zipFileMap.keySet());
    }
    
    
    // returns the list of file names generated by Zipper class
    public Set<String> getFileNames()
    {
        return zipFileMap.keySet();
    }
    
    public Blob getFile(String fileName)
    {
        if (!zipFileMap.containsKey(fileName)) {return null;}

        FileObject tempFileObject = zipFileMap.get(fileName);

        if (tempFileObject.fileDataInZipStr) {
            tempFileObject.readLocalFileHeader(zipFileString, (Integer)HexUtil.hexToIntLittleEndian( tempFileObject.offsetOfLH));
        }

        if (tempFileObject.compressionMethod == '0000')
        {
            return EncodingUtil.convertFromHex(tempFileObject.compressedFileData);
        }
        else {
            System.assert(false,'Unsupported compression method: ' + tempFileObject.compressionMethod);
            return null;
        }
    }
    
    
    // Local File Header
    private final static String LFHSignature = '504b0304';      
    
    
    // Central Directory 
    private final static String CFHSignature = '504b0102';  // little Endian Central file header signature
    
    // Data Descriptor
    private final static String DDSignature = '504b0708';

    // End of Central Directory records
    private final String endCentralDirSignature ='504b0506'; //Little Endian formatted signature (4 bytes)
    private final String numberOfThisDisk = '0000'; // (2 bytes)
    private final String numberOfTheDiskWithStartCentralDir = '0000'; //(2 bytes)
    private String totalNumberOfEntriesInTheCentralDirOnThisDisk =  '0000' ;//(2 bytes)
    private String totalNumberOfEntriesCentralDir  = '0000'; //(2 bytes)
    private String sizeOfCentralDir  = '00000000'; //(4 bytes)
    private String offsetOfStartOfCentralDir = '00000000'; //(4 bytes)
    private final String zipfileCommentLength = '0000';  //(this is c), (2 bytes)
    private final String zipfileComment = '00'; // (c bytes)
    
    
    private String assembleEndOfCentralDir ()
    {
        return endCentralDirSignature + numberOfThisDisk + numberOfTheDiskWithStartCentralDir + totalNumberOfEntriesInTheCentralDirOnThisDisk +
            totalNumberOfEntriesCentralDir  + sizeOfCentralDir + offsetOfStartOfCentralDir +
            zipfileCommentLength + zipfileComment;
    }
    
    
    public Blob getZipFile()
    {
        //if (unZipping)
        //{
        //    return EncodingUtil.convertFromHex(zipFileString);
        //}
        //String zipFileString ='';
        Integer zipFileSize = 0;

        /////// delete central directory and end of Central dir here
        //zipFileString = zipFileString.substringBeforeLast(endCentralDirSignature);
        zipFileString = zipFileString.left((Integer)HexUtil.hexToIntLittleEndian(offsetOfStartOfCentralDir)*2);

        //Writing Local Headers and data for each file
        zipfileSize = zipFileString.length()/2;
        for (FileObject tempFileObject : zipFileMap.values())
        {
            if (!tempFileObject.fileDataInZipStr) {
                tempFileObject.OffsetOfLH = HexUtil.intToHex(zipfileSize, 4);
                zipFileString += tempFileObject.assembleLocalFileHeader();
                zipfileSize = zipFileString.length()/2;
                tempFileObject.fileDataInZipStr = true;
                tempFileObject.compressedFileData = null;
            }
        }

        //Writing Central Directory
        offsetOfStartOfCentralDir = HexUtil.intToHex(zipfileSize,4);
        for (FileObject tempFileObject : zipFileMap.values())
        {
            zipFileString += tempFileObject.assembleCentralFileHeader();
        }
        sizeOfCentralDir = HexUtil.intToHex(zipFileString.length()/2 - zipfileSize,4);
        totalNumberOfEntriesInTheCentralDirOnThisDisk = HexUtil.intToHex(zipFileMap.size(),2);
        totalNumberOfEntriesCentralDir = HexUtil.intToHex(zipFileMap.size(),2);
        
        //Write End of Central Directory
        zipFileString += assembleEndOfCentralDir();
        
        //zipFileMap.clear();

        //System.debug(zipFileString);
        return EncodingUtil.convertFromHex(zipFileString);
    }

    public void removeFileFromZip(String fileName){

        if(!zipFileMap.containsKey(fileName)) {return;}

        FileObject tempFileObject = zipFileMap.get(fileName);
        //zipFileString = zipFileString.substringBeforeLast(LFHSignature); /////update this 

        Integer offsetOfLH = (Integer)HexUtil.hexToIntLittleEndian(tempFileObject.offsetOfLH);

        tempFileObject.readLocalFileHeader(zipFileString, offsetOfLH);

        //Integer sizeOfLH = 30 + (Integer)HexUtil.hexToIntLittleEndian(tempFileObject.fileNameLength)
        //                      + (Integer)HexUtil.hexToIntLittleEndian(tempFileObject.extraFieldLength)
        //                      + (Integer)HexUtil.hexToIntLittleEndian(tempFileObject.compressedSize);
        
        System.debug('offset LH: '+offsetOfLH+' size LH xx  -- fileNameLength '+tempFileObject.fileNameLength+' extraFieldLength '+tempFileObject.extraFieldLength+' compressedSize '+tempFileObject.compressedSize);
        System.debug('offset Next rec: '+tempFileObject.l_offsetToNextRecord);

        zipFileString = zipFileString.left(offsetOfLH*2) + zipFileString.substring(tempFileObject.l_offsetToNextRecord*2); 

        recalculateOffsets(offsetOfLH, offsetOfLH - tempFileObject.l_offsetToNextRecord );

        zipFileMap.remove(fileName);
    }

    private void recalculateOffsets(Integer offset, Integer delta){
    
        for (FileObject tempFileObject : zipFileMap.values()){

            if(tempFileObject.fileDataInZipStr && HexUtil.hexToIntLittleEndian(tempFileObject.offsetOfLH) > offset){
                tempFileObject.offsetOfLH = HexUtil.intToHex((Integer)HexUtil.hexToIntLittleEndian(tempFileObject.offsetOfLH) + delta, 4);
            }
        }
        offsetOfStartOfCentralDir = HexUtil.intToHex((Integer)HexUtil.hexToIntLittleEndian(offsetOfStartOfCentralDir) + delta , 4);
    }

    public void addFileToZip(String fileName, Blob fileData, String crc32)
    {

        if(zipFileMap.containsKey(fileName)){
            removeFileFromZip(fileName);
        }

        FileObject tempFileObject = new FileObject();
        
        tempFileObject.lastModTime = HexUtil.intToHex(getCurrentTime(),2); // (2 bytes) 
        tempFileObject.lastModDate = HexUtil.intToHex(getCurrentDate(),2); // (2 bytes)
        
        //tempFileObject.CRC32 = HexUtil.intToHex(HexUtil.CRC32Table(fileData),4);// (4 bytes) 
        tempFileObject.crc32 = crc32;


        tempFileObject.uncompressedSize = HexUtil.intToHex(fileData.size(), 4);// (4 bytes) 
        tempFileObject.compressedSize = tempFileObject.uncompressedSize;// (4 bytes), creates (n)
    
        tempFileObject.fileNameLength = HexUtil.intToHex(fileName.length(), 2);// (2 bytes), creates (f)
    
        //tempFileObject.extraFieldLength = '1C00';// (2 bytes) , creates (e)
        tempFileObject.extraFieldLength = '0000';// (2 bytes) , creates (e)
        tempFileObject.fileCommentLength = '0000';// (2 bytes), creates (c)
        tempFileObject.diskNumStart = '0000';// (2 bytes) 
        tempFileObject.internalFileAtt = '0000';// (2 bytes) //Internal file attributes
        tempFileObject.externalFileAtt = '0000A481';// (4 bytes) //External file attributes
    
        tempFileObject.fileName = EncodingUtil.convertToHex(Blob.valueOf(fileName));// (f bytes) // from the parameters passed
    
    
        // tempFileObject.extraField = '5554090003CD16C3544017C35475780B000104F60100000414000000';// (e bytes) 
        tempFileObject.extraField = '';
        // tempFileObject.fileComment = '00';// (c bytes) 
        tempFileObject.fileComment = '';// (c bytes) 
    
        tempFileObject.compressedFileData = EncodingUtil.convertToHex(fileData); // (n bytes) // from the parameters passed
        tempFileObject.fileDataInZipStr = false;

        zipFileMap.put(fileName, tempFileObject);  //add the new subFile to the Zip List
    }
    ////////use intToHex instead?
    //public String returnLEHexStringOfDecimal (Integer decimalNumber, Integer sizeInBytes)
    //{
    //    String LEHexStringOfDecimal = '';
    //    Integer remainder = 0;
    //    Integer byteLocation = 0;
    //    String tempRightDigit ='0';
    //    String tempLeftDigit ='0';
    //    while (decimalnumber > 0)
    //    {
    //        remainder = math.mod(decimalnumber, 16);
    //        decimalnumber = decimalnumber / 16;
    //        if (remainder == 1) tempRightDigit = '1';
    //        if (remainder == 2) tempRightDigit = '2';
    //        if (remainder == 3) tempRightDigit = '3';
    //        if (remainder == 4) tempRightDigit = '4';
    //        if (remainder == 5) tempRightDigit = '5';
    //        if (remainder == 6) tempRightDigit = '6';
    //        if (remainder == 7) tempRightDigit = '7';
    //        if (remainder == 8) tempRightDigit = '8';
    //        if (remainder == 9) tempRightDigit = '9';
    //        if (remainder == 10) tempRightDigit = 'a';
    //        if (remainder == 11) tempRightDigit = 'b';
    //        if (remainder == 12) tempRightDigit = 'c';
    //        if (remainder == 13) tempRightDigit = 'd';
    //        if (remainder == 14) tempRightDigit = 'e';
    //        if (remainder == 15) tempRightDigit = 'f';
            
    //        if (remainder == 0)  tempRightDigit = '0';
    //                remainder = math.mod(decimalnumber, 16);
    //                decimalnumber = decimalnumber / 16;
    //                    if (remainder == 0) tempLeftDigit = '0';
    //                    if (remainder == 1) tempLeftDigit = '1';
    //                    if (remainder == 2) tempLeftDigit = '2';
    //                    if (remainder == 3) tempLeftDigit = '3';
    //                    if (remainder == 4) tempLeftDigit = '4';
    //                    if (remainder == 5) tempLeftDigit = '5';
    //                    if (remainder == 6) tempLeftDigit = '6';
    //                    if (remainder == 7) tempLeftDigit = '7';
    //                    if (remainder == 8) tempLeftDigit = '8';
    //                    if (remainder == 9) tempLeftDigit = '9';
    //                    if (remainder == 10) tempLeftDigit = 'a';
    //                    if (remainder == 11) tempLeftDigit = 'b';
    //                    if (remainder == 12) tempLeftDigit = 'c';
    //                    if (remainder == 13) tempLeftDigit = 'd';
    //                    if (remainder == 14) tempLeftDigit = 'e';
    //                    if (remainder == 15) tempLeftDigit = 'f';
             
    //         LEHexStringOfDecimal = LEHEXStringOfDecimal + tempLeftDigit + tempRightDigit;
    //         byteLocation++;
    //    }
    //    for (Integer x = byteLocation; x < sizeInBytes; x++)
    //        LEHexStringOfDecimal = LEHexStringOfDecimal + '00';
        
    //    return LEHexStringOfDecimal;
    //}
    

    public void removePrefix(String prefix)
    {
        String newDataStr, oldDataStr, fileName, extraField, oldCentralDirStr, newCentralDirStr;
        Integer fileNameLength, extraFieldLength;
        prefix = EncodingUtil.convertToHex(Blob.valueOf(prefix));
        for (FileObject tempFO : zipFileMap.values())
        {
            fileName = tempFO.fileName;
            extraField = tempFO.extraField;
            oldDataStr = tempFO.fileNameLength + tempFO.extraFieldLength + fileName + extraField;
 
            fileNameLength = (Integer)HexUtil.hexToIntLittleEndian(tempFO.fileNameLength) - prefix.length()/2;
            extraFieldLength = (Integer)HexUtil.hexToIntLittleEndian(tempFO.extraFieldLength) + prefix.length()/2;
            newDataStr = hexUtil.intToHex(fileNameLength,2) + hexUtil.intToHex(extraFieldLength,2);
            newDataStr += fileName.removeStart(prefix) + extraField + hexUtil.intToHex(0,prefix.length()/2);

            oldCentralDirStr = tempFO.fileNameLength + tempFO.extraFieldLength + tempFO.fileCommentLength + 
                tempFO.diskNumStart + tempFO.internalFileAtt + tempFO.externalFileAtt + tempFO.offsetOfLH + 
                tempFO.fileName + tempFO.extraField;

            newCentralDirStr = hexUtil.intToHex(fileNameLength,2) + hexUtil.intToHex(extraFieldLength,2) + 
                tempFO.fileCommentLength +    tempFo.diskNumStart + tempFO.internalFileAtt + 
                tempFO.externalFileAtt + tempFO.offsetOfLH + 
                fileName.removeStart(prefix) + extraField + hexUtil.intToHex(0,prefix.length()/2);

            if(fileName.startsWith(prefix))
            {
                zipFileString = zipFileString.replace(oldDataStr,newDataStr);
                zipFileString = zipFileString.replace(oldCentralDirStr, newCentralDirStr);
                //System.debug(oldDataStr);
                //System.debug(newDataStr);

            }
        }

    }


    public static Integer getCurrentTime()
    {
        Datetime d = Datetime.now();
        Integer zipTimeStamp = d.hour();
        zipTimeStamp <<= 6;
        zipTimeStamp |= d.minute();
        zipTimeStamp <<= 5;
        zipTimeStamp |= d.second() / 2;
        
        return zipTimeStamp;
    }
    
    public static Integer getCurrentDate()
    {
        Datetime d = Datetime.now();
        Integer zipDateStamp = d.year() - 1980;
        zipDateStamp <<= 4;
        zipDateStamp |= d.month();
        zipDateStamp <<= 5;
        zipDateStamp |= d.day();
    
        return zipDateStamp;
    }

    public class FileObject
    {
        //All strings are hex representations in little endian format
        public String creatorVersion = '0A00'; // (2 bytes) likely Windows NT
        public String minExtractorVersion = '0A00'; // (2 bytes) likely Windows NT
        public String gPFlagBit = '0000';  // (2 bytes) general purpose flag bit
        public String compressionMethod = '0000'; // (2 bytes) no compression
        public String lastModTime = '0000';// (2 bytes) 
        public String lastModDate = '0000';// (2 bytes) 
        public String crc32 = null;// (4 bytes) 
        public String compressedSize = '01000000';// (4 bytes), creates (n)
        public String uncompressedSize = '00000000';// (4 bytes) 
        public String fileNameLength = '01000000';// (2 bytes), creates (f)
        public String extraFieldLength = '0000';// (2 bytes) , creates (e)
        public String fileCommentLength = '0000';// (2 bytes), creates (c)
        public String diskNumStart = '0000';// (2 bytes) 
        public String internalFileAtt = '0000';// (2 bytes) 
        public String externalFileAtt = '00000000';// (4 bytes) 
        public String offsetOfLH = '00000000';// (4 bytes) 
        public String fileName = '00';// (f bytes) 
        public String extraField = '00';// (e bytes) 
        public String fileComment = '00';// (c bytes) 
        public String compressedFileData = '00';// (n bytes)
        public Integer c_offsetToNextRecord = 0;  //offsetToNext Record
        public Boolean fileDataInZipStr = false;
    
        public Integer l_offsetToNextRecord = 0;  //offsetToNext Record

    
        // Constructor
        public FileObject(){
            fileDataInZipStr = false;
        }

        //Reading Central Directory File Header
        public FileObject (String zipFileString, Integer offset)
        {
        offset *=2;

        creatorVersion = zipFileString.substring(offset+4*2, offset+4*2 + 2*2); // (2 bytes) likely Windows NT  Offset 4
        minExtractorVersion = zipFileString.substring(offset+6*2, offset+6*2 + 2*2); // (2 bytes) likely Windows NT  Offset 6
        gPFlagBit = zipFileString.substring(offset+8*2, offset+8*2 + 2*2);  // (2 bytes) general purpose flag bit  Offset 8
        compressionMethod = zipFileString.substring(offset+10*2, offset+10*2 + 2*2); // (2 bytes) no compression  Offset 10
        lastModTime = zipFileString.substring(offset+12*2, offset+12*2 + 2*2);// (2 bytes)   Offset 12
        lastModDate = zipFileString.substring(offset+14*2, offset+14*2 + 2*2);// (2 bytes)    Offset 14
        crc32 = zipFileString.substring(offset+16*2, offset+16*2 + 4*2);// (4 bytes)      Offset 16
        compressedSize = zipFileString.substring(offset+20*2, offset+20*2 + 4*2);// (4 bytes), creates (n)     Offset 20
        uncompressedSize = zipFileString.substring(offset+24*2, offset+24*2 + 4*2);// (4 bytes)      Offset 24
        fileNameLength = zipFileString.substring(offset+28*2, offset+28*2 + 2*2);// (2 bytes), creates (f)     Offset 28
        extraFieldLength = zipFileString.substring(offset+30*2, offset+30*2 + 2*2);// (2 bytes) , creates (e)     Offset 30
        fileCommentLength = zipFileString.substring(offset+32*2, offset+32*2 + 2*2);// (2 bytes), creates (c)     Offset 32
        diskNumStart = zipFileString.substring(offset+34*2, offset+34*2 + 2*2);// (2 bytes)     Offset 34
        internalFileAtt = zipFileString.substring(offset+36*2, offset+36*2 + 2*2);// (2 bytes)      Offset 36
        externalFileAtt = zipFileString.substring(offset+38*2, offset+38*2 + 4*2);// (4 bytes)     Offset 38
        offsetOfLH = zipFileString.substring(offset+42*2, offset+42*2 + 4*2);// (4 bytes)     Offset 42
        
        offset = offset /2;

        Integer theStart = offset+46;
        Integer theEnd = theStart + (Integer)HexUtil.hexToIntLittleEndian(fileNameLength);
        fileName = zipFileString.substring(theStart*2, theEnd*2);// (f bytes)       Offset 46
        theStart = theEnd;
        theEnd = theStart + (Integer)HexUtil.hexToIntLittleEndian(extraFieldLength);
        extraField = zipFileString.substring(theStart*2, theEnd * 2);// (e bytes)        Offset 46 + fileNameLength
        theStart = theEnd;
        theEnd = theStart + (Integer)HexUtil.hexToIntLittleEndian(fileCommentLength);
        fileComment = zipFileString.substring(theStart*2, theEnd*2);// (c bytes)        Offset 46 + fileNameLength + extraFieldLength
        c_offsetToNextRecord = theEnd;
        fileDataInZipStr = true; //true beacause we are reading an existing zip file
        //System.debug(this);
        }
        
        //Reading Local File Header (which also contains the data)
        public void readLocalFileHeader (String zipFileString, Integer offset)
        {
            Integer strOffset = offset *2;

            minExtractorVersion = zipFileString.substring(strOffset+4*2, strOffset+4*2 + 2*2); // (2 bytes) likely Windows NT  Offset 4
            gPFlagBit = zipFileString.substring(strOffset+6*2, strOffset+6*2 + 2*2);  // (2 bytes) general purpose flag bit  Offset 6
            compressionMethod = zipFileString.substring(strOffset+8*2, strOffset+8*2 + 2*2); // (2 bytes) no compression  Offset 8
            lastModTime = zipFileString.substring(strOffset+10*2, strOffset+10*2 + 2*2);// (2 bytes)   Offset 10
            lastModDate = zipFileString.substring(strOffset+12*2, strOffset+12*2 + 2*2);// (2 bytes)    Offset 12
            
            System.debug('gPFlagBit '+gPFlagBit);
            if ((hexUtil.hexToIntLittleEndian(gPFlagBit.left(2)) & 8 ) == 0) {
                crc32 = zipFileString.substring(strOffset+14*2, strOffset+14*2 + 4*2);// (4 bytes)      Offset 14
                compressedSize = zipFileString.substring(strOffset+18*2, strOffset+18*2 + 4*2);// (4 bytes), creates (n)     Offset 18
                uncompressedSize = zipFileString.substring(strOffset+22*2, strOffset+22*2 + 4*2);// (4 bytes)      Offset 22
            }

            fileNameLength = zipFileString.substring(strOffset+26*2, strOffset+26*2 + 2*2);// (2 bytes), creates (f)     Offset 26
            extraFieldLength = zipFileString.substring(strOffset+28*2, strOffset+28*2 + 2*2);// (2 bytes) , creates (e)     Offset 28

            //offset = offset /2;

            Integer theStart = offset+30;
            Integer theEnd = theStart + (Integer)HexUtil.hexToIntLittleEndian(fileNameLength);
            fileName = zipFileString.substring(theStart*2, theEnd*2);// (f bytes)       Offset 30
            theStart = theEnd;
            theEnd = theStart + (Integer)HexUtil.hexToIntLittleEndian(extraFieldLength);
            extraField = zipFileString.substring(theStart*2, theEnd * 2);// (e bytes)        Offset 30 + fileNameLength
            theStart = theEnd;
            theEnd = theStart + (Integer)HexUtil.hexToIntLittleEndian(compressedSize);
            compressedFileData = zipFileString.substring(theStart*2, theEnd*2);// (c bytes)        Offset 30 + fileNameLength + extraFieldLength
            l_offsetToNextRecord = theEnd;
            
            if ((hexUtil.hexToIntLittleEndian(gPFlagBit.left(2)) & 8 ) != 0) {
                l_offsetToNextRecord *= 2;
                String signature = zipFileString.substring(l_offsetToNextRecord+0*2, l_offsetToNextRecord+0*2 + 4*2);// (4 bytes)
                if (signature != DDSignature) {l_offsetToNextRecord -= 4*2;}
                crc32 = zipFileString.substring(l_offsetToNextRecord+4*2, l_offsetToNextRecord+4*2 + 4*2);// (4 bytes)      Offset 0/4
                compressedSize = zipFileString.substring(l_offsetToNextRecord+8*2, l_offsetToNextRecord+8*2 + 4*2);// (4 bytes), creates (n)     Offset 4/8
                uncompressedSize = zipFileString.substring(l_offsetToNextRecord+12*2, l_offsetToNextRecord+12*2 + 4*2);// (4 bytes)      Offset 8/12
                l_offsetToNextRecord /= 2;
                l_offsetToNextRecord += 16; 
            }

            System.debug('local file header ' + this);
        
        }

        public String assembleLocalFileHeader()
        {
            if (String.isBlank(crc32)) {  
                crc32 = HexUtil.intToHex(HexUtil.CRC32Table(compressedFileData), 4);// (4 bytes) 
            }
            return Zipper.LFHSignature + minExtractorVersion + GPFlagBit + compressionMethod +lastModTime + lastModDate + 
                    crc32 + compressedSize + uncompressedSize + fileNameLength + extraFieldLength + fileName + extraField +
                    compressedFileData;
        }

        public String assembleCentralFileHeader()
        {
            if (String.isBlank(crc32)) {  
                crc32 = HexUtil.intToHex(HexUtil.CRC32Table(compressedFileData), 4);// (4 bytes) 
            }
            return Zipper.CFHSignature + creatorVersion + minExtractorVersion + GPFlagBit + compressionMethod +lastModTime + lastModDate
                    + crc32 + compressedSize + uncompressedSize + fileNameLength + extraFieldLength
                    + fileCommentLength + diskNumStart + internalFileAtt + externalFileAtt + offsetOfLH + fileName 
                    + extraField + fileComment;
        }
    }// end of FileObject class
}